<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Error Model Viewer 2D</title>
    <link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css">
</head>
<style>
.abs {
    position: absolute;
}
html, body {
    width: 100%;
    height: 100%;
    margin: 0;
    font-family: courier, serif;
}
p {
    margin: 0;
}
.el-slider__runway {
    margin: 0 !important;
}
.el-slider__stop {
    background-color: rgb(202, 202, 202) !important;
}
textarea {
    line-height: 1.5;
    border-radius: 5px;
    border: 1px solid #ccc;
    box-shadow: 1px 1px 1px #999;
    word-break: break-all;
}
.qubit:hover {
    background-color: rgb(255, 145, 0) !important;
}
.demo {
    display: inline-block;
    position: relative;
}
</style>
<body>

<script src="https://unpkg.com/vue@2.6.14/dist/vue.js"></script>
<script src="https://unpkg.com/element-ui/lib/index.js"></script>
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<div id="app" style="width: 100%; height: 100%;">
    <div class="abs" style="background-color: white" :style="{ width: main_width+'px', height: main_height+'px', left: ((window_width-main_width)/2)+'px', top: ((window_height-main_height)/2)+'px' }">
        <div v-if="!data_ready" class="abs" style="background-color: rgb(253, 204, 204); text-align: center;" :style="{ width: main_height+'px', height: main_height+'px', 'line-height': main_height+'px', left: 0, top: 0, 'font-size': (70*scale)+'px' }">Loading...</div>
        <textarea readonly v-if="data_error != null" class="abs" style="background-color: rgb(255, 147, 147); border: 0; border-radius: 0; resize: none; padding: 0; outline: none;"
            :style="{ width: main_height+'px', height: main_height+'px', left: 0, top: 0, 'font-size': (30*scale)+'px' }">{{ data_error }}</textarea>
        <div v-if="data_ready" class="abs" :style="{ width: main_height+'px', height: main_height+'px', left: 0, top: 0 }">
            <canvas class="abs" id="behind_canvas" :width="main_height + 'px'" :height="main_height + 'px'" style="pointer-events:none;"></canvas>  
            <div class="abs" style="width: 100%; height: 100%; top: 0; left: 0" @click="select_node(null)"></div>
            <div v-for="(item, i) in data.nodes[t]">
                <div v-for="(node, j) in data.nodes[t][i]">
                    <div v-if="node != null && !node.is_virtual" class="abs qubit" style="border-radius: 100%;" :style="{ 'background-color': qubit_color(node), width: (qubit_radius*2)+'px', height: (qubit_radius*2)+'px', left: pos(j)+'px', top: pos(i)+'px' }"
                        @click="select_node(node)"></div>
                </div>
            </div>
            <canvas class="abs" id="front_canvas" :width="main_height + 'px'" :height="main_height + 'px'" style="pointer-events:none;"></canvas>  
        </div>
        <div class="abs" style="background-color: white;" :style="{ width: (main_height*0.05)+'px', height: main_height+'px', left: main_height+'px', top: 0 }">
            <el-slider v-model="t" vertical :height="(main_height*0.96)+'px'" :min="0" :max="36" :step="1" :show-stops="true" :style="{ margin: `${20*scale}px 0 0 ${25*scale}px` }" :marks="marks"></el-slider>
        </div>
        <div class="abs" style="right: 0; top: 0;" :style="{ width: (main_width-main_height*1.15)+'px', height: main_height+'px' }">
            <div :style="{ margin: (20*scale)+'px', 'font-size': (18*scale)+'px' }">
                <p style="font-size: 160%; font-weight: bold;">Error Model<span v-if="data_ready" style="font-weight: normal;"> ({{ Object.keys(data.code_type)[0] }})</span></p>
                <p style="font-size: 100%; max-width: 100%;" :style="{ 'margin-top': (20*scale)+'px' }">parameters: \( d_i = d_j = T = \;\){{di}}, \( p_{\small\text{Pauli}} = \;\){{p_str}}, \(p_{\small\text{erasure}} = \;\){{pe_str}}</p>
                <textarea style="width: 95%; resize: none;" :style="{ padding: (10*scale)+'px', 'margin-top': (10*scale)+'px', 'font-size': (14*scale)+'px' }" id="parameters-textarea" rows="3" v-model="full_parameters" v-on:keypress="textarea_keypress" v-on:blur="textarea_updated"></textarea>
                <div style="font-size: 80%; font-family: arial; color: grey;">
                    <p>- Errors are placed *after* the gate (thus any ancilla error at measurement stage is meaningless because it's after the current measurement and before the next initialization; in order to add pure additional measurement errors, add them to gate4 stage as single-qubit pauli error)</p>
                    <p>- <span><span class="demo":style="{ width: (20*scale)+'px', height: (20*scale)+'px', 'border-radius': (20*scale)+'px', 'top': (5*scale)+'px', 'margin-right': (5*scale)+'px', 'background-color': pauli_color }"></span>single-qubit Pauli error</span>
                         <span><span class="demo":style="{ width: (20*scale)+'px', height: (20*scale)+'px', 'border-radius': (20*scale)+'px', 'top': (5*scale)+'px', 'margin-right': (5*scale)+'px', 'background-color': erasure_color }"></span>single-qubit erasure error</span></p>
                    <p>- <span><span class="demo":style="{ width: (30*scale)+'px', height: (20*scale)+'px', 'top': (5*scale)+'px', 'margin-right': (5*scale)+'px', 'background-color': pauli_color }"></span>correlated two-qubit Pauli error</span>
                        <span><span class="demo":style="{ width: (30*scale)+'px', height: (20*scale)+'px', 'top': (5*scale)+'px', 'margin-right': (5*scale)+'px', 'background-color': erasure_color }"></span>correlated two-qubit erasure error</span></p>
                    <p>- <span v-if="data_ready" v-for="qubit_type of existing_qubit_types" :style="{ 'margin-right': (10*scale)+'px' }"><span class="demo"
                         :style="{ width: (20*scale)+'px', height: (20*scale)+'px', 'border-radius': (20*scale)+'px', 'top': (5*scale)+'px', 'margin-right': (5*scale)+'px', 'background-color': qubit_type_color(qubit_type) }"></span>{{ qubit_type_name(qubit_type) }} Qubit</span></p>
                </div>
                <div v-if="data_ready" v-show="selected != null">
                    <div v-for="node of [data.nodes[t][si][sj]]">
                        <div v-if="node != null">
                            <p style="font-size: 150%; font-weight: bold;" :style="{ 'margin-top': (10*scale)+'px' }">{{ qubit_type_name(node.qubit_type) }} Qubit at [{{t}}][{{si}}][{{sj}}]</p>
                            <p style="font-size: 100%; font-weight: bold;" :style="{ 'margin-top': (10*scale)+'px' }">Single-Qubit Pauli Error:
                                <p :style="{ color: node.error_model.pp.px > 2e-300 ? non_zero_color : zero_color, 'margin-left': (40*scale)+'px' }">\( p_{\small X} = \;\)<span>{{ node.error_model.pp.px }}</span></p>
                                <p :style="{ color: node.error_model.pp.pz > 2e-300 ? non_zero_color : zero_color, 'margin-left': (40*scale)+'px' }">\( p_{\small Z} = \;\)<span>{{ node.error_model.pp.pz }}</span></p>
                                <p :style="{ color: node.error_model.pp.py > 2e-300 ? non_zero_color : zero_color, 'margin-left': (40*scale)+'px' }">\( p_{\small Y} = \;\)<span>{{ node.error_model.pp.py }}</span></p></p>
                                <p :style="{ color: node.error_model.pp.px + node.error_model.pp.pz + node.error_model.pp.py > 4e-300 ? non_zero_color : zero_color, 'margin-left': (40*scale)+'px' }">
                                    \( p_{\small X} + p_{\small Z} + p_{\small Y} = \;\)<span>{{ node.error_model.pp.px + node.error_model.pp.pz + node.error_model.pp.py }}</span></p></p>
                            <p style="font-size: 100%; font-weight: bold;" :style="{ 'margin-top': (10*scale)+'px' }">Single-Qubit Erasure Error: 
                                <p :style="{ color: node.error_model.pe > 0 ? non_zero_color : zero_color, 'margin-left': (40*scale)+'px' }">\( p_{\small\text{erasure}} = \;\)<span>{{ node.error_model.pe }}</span></p></p>
                            <div v-show="node.gate_peer != null">
                                <p style="font-size: 100%; font-weight: bold;" :style="{ 'margin-top': (10*scale)+'px' }">Peer Qubit of this Two-Qubit Gate: {{ node.gate_peer }}</p>
                                <p style="font-size: 100%; font-weight: bold;" :style="{ 'margin-top': (10*scale)+'px' }">Correlated Two-Qubit Pauli Error: (this \(\otimes\) peer)
                                    <p v-for="name of all_correlated_pauli_names" :style="{ color: (node.error_model.corr_pp||all_zero_correlated_pauli)[`p${name.toLowerCase()}`] > 0 ? non_zero_color : zero_color, 'margin-left': (40*scale)+'px' }">
                                        \( p_{\small {{ name[0] }} \otimes {{ name[1] }}} = \;\)<span>{{ (node.error_model.corr_pp||all_zero_correlated_pauli)[`p${name.toLowerCase()}`] }}</span></p></p>
                                    <p :style="{ color: sum_correlated_pauli(node) > 0 ? non_zero_color : zero_color, 'margin-left': (40*scale)+'px' }">\( \sum p_{\small \cdots \otimes \cdots} = \;\)<span>{{ sum_correlated_pauli(node) }}</span></p>
                                <p style="font-size: 100%; font-weight: bold;" :style="{ 'margin-top': (10*scale)+'px' }">Correlated Two-Qubit Erasure Error: (this \(\otimes\) peer)
                                    <p v-for="name of all_correlated_erasure_names" :style="{ color: (node.error_model.corr_pe||all_zero_correlated_erasure)[`p${name.toLowerCase()}`] > 0 ? non_zero_color : zero_color, 'margin-left': (40*scale)+'px' }">
                                        \( p_{\small {{ name[0] }} \otimes {{ name[1] }}} = \;\)<span>{{ (node.error_model.corr_pe||all_zero_correlated_erasure)[`p${name.toLowerCase()}`] }}</span></p></p>
                                    <p :style="{ color: sum_correlated_erasure(node) > 0 ? non_zero_color : zero_color, 'margin-left': (40*scale)+'px' }">\( p_{\small I \otimes E} + p_{\small E \otimes I} + p_{\small E \otimes E} = \;\)<span>{{ sum_correlated_erasure(node) }}</span></p>
                            </div>
                        </div>
                    </div>
                </div>
                <div v-if="selected == null">
                    <p style="font-size: 100%; font-weight: bold; color: blue;" :style="{ 'margin-top': (20*scale)+'px' }">👈 Click qubit on the left to view error model</p>
                </div>
            </div>
        </div>
    </div>
</div>

<script>

var base_url = "https://qec.wuyue98.cn/api/view_error_model"
if (window.location.href.startsWith("file://")) {
    console.log("[info] detected you're using local file, development url is used. start local server using `cargo run -- server`.")
    base_url = "http://127.0.0.1:8066/view_error_model"  // start local server using `cargo run -- server`
}

// debug url: ?p=0.01&pe=0.05&parameters=--code_type StandardXZZXCode --error_model only-gate-error-circuit-level --error_model_configuration '{"use_correlated_pauli":true,"use_correlated_erasure":true}'
// debug url: ?p=0.01&pe=0.05&parameters=--code_type StandardXZZXCode --error_model only-gate-error-circuit-level --error_model_configuration '{"use_correlated_pauli":true,"use_correlated_erasure":true,"initialization_error_rate":0.005,"measurement_error_rate":0.005}'

async function get_error_model_data() {
    const url = base_url + window.location.search
    // console.log(url)
    const response = await axios.get(url)
    return response.data
}

function get_position(position_str) {
    const matched_pos = position_str.match(/^\[(\d+)\]\[(\d+)\]\[(\d+)\]$/)
    return {
        t: parseInt(matched_pos[1]),
        i: parseInt(matched_pos[2]),
        j: parseInt(matched_pos[3]),
    }
}

const di = 5

const urlParams = new URLSearchParams(window.location.search)
const p_str = urlParams.get('p') || 0
const pe_str = urlParams.get('pe') || 0
const error_model_temporary_id = urlParams.get('error_model_temporary_id') || 0
const parameters = urlParams.get('parameters') || ""
const full_parameters = `"[${di}]" --djs "[${di}]" "[${di}]" "[${p_str}]" --pes "[${pe_str}]" ${parameters}`

function create_marks(scale=1) {
    let marks = {}
    let make_mark = (name, color='grey', font_weight="normal") => {
        return {
            style: {
                color: color,
                'font-size': `${25*scale}px`,
                'font-weight': font_weight,
            },
            label: name
        }
    }
    marks[0] = make_mark(`time`, color="black")
    for (let mt = 0; mt <= di; mt++) {
        const t = 6 * (mt + 1)
        marks[t] = make_mark(`meas${mt}`, color="#1989FA", font_weight="bold")
        marks[t-1] = make_mark(`gate4`)
        marks[t-2] = make_mark(`gate3`)
        marks[t-3] = make_mark(`gate2`)
        marks[t-4] = make_mark(`gate1`)
        marks[t-5] = make_mark(`init`)
    }
    return marks
}

var app = new Vue({
    el: '#app',
    data: function() {
        return {
            window_width: 0,
            window_height: 0,
            main_width: 0,
            main_height: 0,
            scale: 1,
            data_ready: false,
            t: 21,
            marks: create_marks(),
            full_parameters: full_parameters,
            last_confirmed_parameters: full_parameters,
            di: di,
            p_str: p_str,
            pe_str: pe_str,
            selected: null,
            default_selection: [0, 0],
            non_zero_color: "red",
            zero_color: "grey",
            all_correlated_pauli_names: [],
            all_zero_correlated_pauli: {},
            all_correlated_erasure_names: ["IE", "EI", "EE"],
            all_zero_correlated_erasure: {
                "error_rate_IE": 0.0,
                "error_rate_EI": 0.0,
                "error_rate_EE": 0.0,
            },
            data: null,
            data_error: null,
            existing_qubit_types: [],
            pauli_color: "purple",
            erasure_color: "green",
        }
    },
    async mounted() {
        if (error_model_temporary_id > 0) {
            this.$message({
                message: "You're viewing a temporary error model, which might be removed soon",
                type: "warning",
            })
        }
        if (isNaN(p_str) || isNaN(pe_str)) {
            this.$message.error("p or pe is not a float number, format error")
        }
        // generate static information
        for (let first of ["I", "X", "Z", "Y"]) {
            for (let second of ["I", "X", "Z", "Y"]) {
                if (first == "I" && second == "I") continue
                this.all_correlated_pauli_names.push(`${first}${second}`)
                this.all_zero_correlated_pauli[`error_rate_${first}${second}`] = 0.
            }
        }
        // fetch data from server
        try {
            this.data = await get_error_model_data()
        } catch (e) {
            if (e == undefined) {
                this.data_error = `server failed, please contact admin`
                return
            }
            let remove_ansi_color = (s) => {
                // https://unpkg.com/ansicolor@1.1.95/build/ansicolor.js
                return s.replace(/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g, '')
            }
            this.data_error = `${e.response.status} ${e.response.statusText}\n\n${remove_ansi_color(e.response.data)}`
            return
        }
        this.fill_data()
        let found_qubit_types = {}
        for (let row of this.data.nodes[0]) {
            for (let node of row) {
                if (node != null) {
                    this.default_selection = [node.i, node.j]
                    found_qubit_types[this.qubit_type_name(node.qubit_type)] = true
                }
            }
        }
        let all_qubit_types = ["Data", "StabX", "StabZ", "StabXZZXLogicalX", "StabY"]  // StabXZZXLogicalZ is not necessary
        for (let qubit_type of all_qubit_types) {
            if (found_qubit_types[this.qubit_type_name(qubit_type)]) {
                this.existing_qubit_types.push(qubit_type)
            }
        }
        console.assert(this.data.vertical == 2 * di + 1)
        console.assert(this.data.horizontal == 2 * di + 1)
        console.assert(this.data.height == 6 * (di + 1) + 1)
        this.data_ready = true
        this.data_error = null
        this.update_mathjax()
        this.$nextTick(async () => {
            this.update_canvas()
        })
    },
    methods: {
        textarea_updated() {
            console.log(this.full_parameters)
            if (this.full_parameters == this.last_confirmed_parameters) {
                return  // not changed, no need to refresh
            }
            const found = this.full_parameters.match(/^"\[(\d+)\]" +--djs +"\[(\d+)\]" +"\[(\d+)\]" +"\[([+-e\d\.]+)\]" +--pes +"\[([+-e\d\.]+)\]"( (.*))?/)
            if (found == null) {
                this.$message.error("parameter format error")
                return
            }
            console.log(found)
            const names = ["di", "dj", "T", "p_pauli", "p_erasure"]
            for (let i=1; i <= 5; ++i) {
                if (isNaN(found[i])) {
                    this.$message.error(`invalid format: ${names[i-1]}`)
                    return
                }
            }
            for (let i=1; i <= 3; ++i) {
                if (parseInt(found[i]) != di) {
                    this.$message.error(`current visualization doesn't support any other di,dj,T values, they must all be ${di}`)
                    return
                }
            }
            let p_str = found[4]
            let pe_str = found[5]
            let parameters_str = found.length <= 7 ? "" : found[7] || ""
            let composed_configure = `[${di}] --djs [${di}] [${di}] [${p_str}] --pes [${pe_str}] ${parameters_str}`
            if (confirm(`apply new configuration and refresh? ${composed_configure}`)) {
                let new_url = window.location.origin + window.location.pathname + `?p=${encodeURIComponent(p_str)}&pe=${encodeURIComponent(pe_str)}&parameters=${encodeURIComponent(parameters_str)}`
                if (error_model_temporary_id > 0) {
                    new_url += `&error_model_temporary_id=${error_model_temporary_id}`
                }
                console.log(new_url)
                window.location.href = new_url
                this.last_confirmed_parameters = this.full_parameters  // to prevent another confirm block
            }
        },
        textarea_keypress(e) {
            if(e.which === 13) {
                e.preventDefault();
                this.textarea_updated()
            }
        },
        update_mathjax() {
            this.$nextTick(async () => {
                await MathJax.typesetPromise()
            })
        },
        on_resize() {
            this.window_width = document.documentElement.clientWidth
            this.window_height = document.documentElement.clientHeight
            // console.log(`${this.window_width} * ${this.window_height}`)
            let ratio = 1920 / 1080
            this.main_width = Math.floor(Math.min(this.window_width, this.window_height * ratio))
            this.main_height = Math.floor(Math.min(this.window_width / ratio, this.window_height))
            this.scale = this.main_width / 1920
            // update
            this.marks = create_marks(this.scale)
            this.$nextTick(async () => {
                this.update_canvas()
            })
        },
        pos(i) {
            return Math.round(this.main_height * (0.5 + (i - di) / di * 0.45) - this.qubit_radius)
        },
        qubit_type_name(qubit_type) {
            if (qubit_type == "StabX") { return "X Ancilla" }
            if (qubit_type == "StabZ") { return "Z Ancilla" }
            if (qubit_type == "StabXZZXLogicalX") { return "XZZX Ancilla" }
            if (qubit_type == "StabXZZXLogicalZ") { return "XZZX Ancilla" }
            if (qubit_type == "StabY") { return "Y Ancilla" }
            return qubit_type
        },
        qubit_type_color(qubit_type) {
            if (qubit_type == "Data") {
                return "grey"
            }
            if (qubit_type == "StabX") {
                return "#FFFF00"
            }
            if (qubit_type == "StabZ") {
                return "#CFE2F3"
            }
            if (qubit_type == "StabXZZXLogicalX" || qubit_type == "StabXZZXLogicalZ") {
                return "#F4CCCC"
            }
            if (qubit_type == "StabY") {
                return "#4287f5"
            }
            return "black"
        },
        qubit_color(node) {
            if (this.selected != null) {
                const [i, j] = this.selected
                if (node.i == i && node.j == j) {
                    return "red"
                }
            }
            return this.qubit_type_color(node.qubit_type)
        },
        select_node(node) {
            if (node == null) {
                this.selected = null
                return
            }
            this.selected = [node.i, node.j]
        },
        sum_correlated_pauli(node) {
            if (node == null || node.error_model == null || node.error_model.corr_pp == null) {
                return 0
            }
            let sum = 0
            for (name of this.all_correlated_pauli_names) {
                sum += node.error_model.corr_pp[`p${name.toLowerCase()}`]
            }
            return sum
        },
        sum_correlated_erasure(node) {
            if (node == null || node.error_model.corr_pe == null) {
                return 0
            }
            let sum = 0
            for (name of this.all_correlated_erasure_names) {
                sum += node.error_model.corr_pe[`p${name.toLowerCase()}`]
            }
            return sum
        },
        fill_data() {  // fill in missing information of the nodes
            for (let t = 0; t < this.data.nodes.length; ++t) {
                for (let i = 0; i < this.data.nodes[t].length; ++i) {
                    for (let j = 0; j < this.data.nodes[t][i].length; ++j) {
                        let node = this.data.nodes[t][i][j]
                        if (node != null) {
                            node.i = i
                            node.j = j
                            node.t = t
                            console.assert(node.position == `[${t}][${i}][${j}]`)
                        }
                    }
                }
            }
        },
        update_canvas() {
            // draw gates
            let canvas = document.getElementById('front_canvas')
            if (canvas && canvas.getContext) {
                let context = canvas.getContext('2d')
                context.clearRect(0, 0, canvas.width, canvas.height)
                let width = canvas.width
                for (let i = 0; i < this.data.nodes[this.t].length; ++i) {
                    for (let j = 0; j < this.data.nodes[this.t][i].length; ++j) {
                        const node = this.data.nodes[this.t][i][j]
                        if (node == null || node.is_virtual || node.is_peer_virtual) continue
                        context.lineWidth = 2 * this.scale
                        context.strokeStyle = 'black'
                        context.fillStyle = "black"
                        if (node.gate_type == "CXGateTarget") {
                            // draw CNOT:target
                            const circle_radius = this.qubit_radius * 0.8
                            context.beginPath()
                            context.arc(this.pos(j) + this.qubit_radius, this.pos(i) + this.qubit_radius, circle_radius, 0, 2 * Math.PI)
                            context.stroke()
                            context.beginPath()
                            context.moveTo(this.pos(j) + this.qubit_radius, this.pos(i) + this.qubit_radius - circle_radius)
                            context.lineTo(this.pos(j) + this.qubit_radius, this.pos(i) + this.qubit_radius + circle_radius)
                            context.stroke()
                            context.beginPath()
                            context.moveTo(this.pos(j) + this.qubit_radius - circle_radius, this.pos(i) + this.qubit_radius)
                            context.lineTo(this.pos(j) + this.qubit_radius + circle_radius, this.pos(i) + this.qubit_radius)
                            context.stroke()
                        } else if (node.gate_type == "CYGateTarget") {
                            const half_square_length = this.qubit_radius * 0.6
                            context.beginPath()
                            context.moveTo(this.pos(j) + this.qubit_radius + half_square_length, this.pos(i) + this.qubit_radius + half_square_length)
                            context.lineTo(this.pos(j) + this.qubit_radius + half_square_length, this.pos(i) + this.qubit_radius - half_square_length)
                            context.lineTo(this.pos(j) + this.qubit_radius - half_square_length, this.pos(i) + this.qubit_radius - half_square_length)
                            context.lineTo(this.pos(j) + this.qubit_radius - half_square_length, this.pos(i) + this.qubit_radius + half_square_length)
                            context.lineTo(this.pos(j) + this.qubit_radius + half_square_length, this.pos(i) + this.qubit_radius + half_square_length)
                            context.stroke()
                            context.font = `${30 * this.scale}px Arial`
                            context.textAlign = "center"
                            context.fillText("Y", this.pos(j) + this.qubit_radius, this.pos(i) + this.qubit_radius + 12 * this.scale)
                        } else if (node.gate_type == "CXGateControl" || node.gate_type == "CZGate" || node.gate_type == "CYGateControl") {
                            // draw CNOT:control
                            const circle_radius = 8 * this.scale
                            context.beginPath()
                            context.arc(this.pos(j) + this.qubit_radius, this.pos(i) + this.qubit_radius, circle_radius, 0, 2 * Math.PI)
                            context.fill()
                        } else if (node.gate_type == "MeasureX" || node.gate_type == "MeasureZ") {
                            let measure_basis = "?"
                            if (node.gate_type == "MeasureX") {
                                measure_basis = "X"
                            }
                            if (node.gate_type == "MeasureZ") {
                                measure_basis = "Z"
                            }
                            context.font = `${30 * this.scale}px Arial`
                            context.textAlign = "center"
                            context.fillText("Meas." + measure_basis, this.pos(j) + this.qubit_radius, this.pos(i) + this.qubit_radius)
                        } else if (node.gate_type == "InitializeX" || node.gate_type == "InitializeZ") {
                            let init_basis = "|?〉"
                            if (node.gate_type == "InitializeX") {
                                init_basis = "|+〉"
                            }
                            if (node.gate_type == "InitializeZ") {
                                init_basis = "|0〉"
                            }
                            context.font = `${30 * this.scale}px Arial`
                            context.textAlign = "center"
                            context.fillText("Init." + init_basis, this.pos(j) + this.qubit_radius, this.pos(i) + this.qubit_radius)
                        }
                        if (node.gate_peer != null) {
                            // draw half of the connection
                            const gate_peer = get_position(node.gate_peer)
                            let ci = gate_peer.i
                            let cj = gate_peer.j
                            context.beginPath()
                            context.moveTo(this.pos(j) + this.qubit_radius, this.pos(i) + this.qubit_radius)
                            context.lineTo(this.pos((j+cj)/2) + this.qubit_radius, this.pos((i+ci)/2) + this.qubit_radius)
                            context.stroke()
                        }
                    }
                }
            }
            // draw errors
            canvas = document.getElementById('behind_canvas')
            if (canvas && canvas.getContext) {
                let context = canvas.getContext('2d')
                context.clearRect(0, 0, canvas.width, canvas.height)
                let width = canvas.width
                for (let i = 0; i < this.data.nodes[this.t].length; ++i) {
                    for (let j = 0; j < this.data.nodes[this.t][i].length; ++j) {
                        const node = this.data.nodes[this.t][i][j]
                        if (node == null) continue
                        context.lineWidth = 0
                        // 1e-300 is used for supporting decoding erasure errors
                        if (node.error_model.pp.px > 2e-300 || node.error_model.pp.pz > 2e-300 || node.error_model.pp.py > 2e-300) {
                            const circle_radius = this.qubit_radius * 1.5
                            context.beginPath()
                            context.arc(this.pos(j) + this.qubit_radius, this.pos(i) + this.qubit_radius, circle_radius, 0, 2 * Math.PI)
                            context.fillStyle = this.pauli_color
                            context.fill()
                        }
                        if (node.error_model.pe > 0) {
                            const circle_radius = this.qubit_radius * 1.25
                            context.beginPath()
                            context.arc(this.pos(j) + this.qubit_radius, this.pos(i) + this.qubit_radius, circle_radius, 0, 2 * Math.PI)
                            context.fillStyle = this.erasure_color
                            context.fill()
                        }
                        if (node.gate_peer != null) {
                            const gate_peer = get_position(node.gate_peer)
                            let ci = gate_peer.i
                            let cj = gate_peer.j
                            const mid_point = 0.6
                            let ei = ci * mid_point + i * (1 - mid_point)
                            let ej = cj * mid_point + j * (1 - mid_point)
                            if (this.sum_correlated_pauli(node) > 0) {
                                let linear_gradident = context.createLinearGradient(this.pos(j) + this.qubit_radius, this.pos(i) + this.qubit_radius, this.pos(ej) + this.qubit_radius, this.pos(ei) + this.qubit_radius)
                                linear_gradident.addColorStop(0, this.pauli_color)
                                linear_gradident.addColorStop(0.6, this.pauli_color)
                                linear_gradident.addColorStop(1, "rgba(255, 255, 255, 0)")
                                context.fillStyle = linear_gradident
                                const expand_width = this.qubit_radius * 0.7
                                let left = Math.min(this.pos(j), this.pos(ej)) + this.qubit_radius - expand_width
                                let right = Math.max(this.pos(j), this.pos(ej)) + this.qubit_radius + expand_width
                                let top = Math.min(this.pos(i), this.pos(ei)) + this.qubit_radius - expand_width
                                let bottom = Math.max(this.pos(i), this.pos(ei)) + this.qubit_radius + expand_width
                                context.fillRect(left, bottom, right - left, top - bottom)
                            }
                            if (this.sum_correlated_erasure(node) > 0) {
                                let linear_gradident = context.createLinearGradient(this.pos(j) + this.qubit_radius, this.pos(i) + this.qubit_radius, this.pos(ej) + this.qubit_radius, this.pos(ei) + this.qubit_radius)
                                linear_gradident.addColorStop(0, this.erasure_color)
                                linear_gradident.addColorStop(0.6, this.erasure_color)
                                linear_gradident.addColorStop(1, "rgba(255, 255, 255, 0)")
                                context.fillStyle = linear_gradident
                                const expand_width = this.qubit_radius * 0.4
                                let left = Math.min(this.pos(j), this.pos(ej)) + this.qubit_radius - expand_width
                                let right = Math.max(this.pos(j), this.pos(ej)) + this.qubit_radius + expand_width
                                let top = Math.min(this.pos(i), this.pos(ei)) + this.qubit_radius - expand_width
                                let bottom = Math.max(this.pos(i), this.pos(ei)) + this.qubit_radius + expand_width
                                context.fillRect(left, bottom, right - left, top - bottom)
                            }
                        }
                    }
                }
            }
        },
    },
    watch: {
        t() {
            this.update_canvas()
        },
    },
    computed: {
        qubit_radius() {
            return 25 * this.scale
        },
        si() {
            if (this.selected == null) return this.default_selection[0]
            return this.selected[0]
        },
        sj() {
            if (this.selected == null) return this.default_selection[1]
            return this.selected[1]
        },
    },
})

app.on_resize()
window.addEventListener('resize', function(event) {
    app.on_resize()
});

</script>

</body>
</html>
